name: Release on POM version

on:
  push:
    branches: [ "main" ]
    paths:
      - "pom.xml"

permissions:
  contents: write
  packages: write

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # we need tags/history

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "21"
          cache: maven

      - name: Read project version from pom.xml
        id: ver
        shell: bash
        run: |
          set -euo pipefail
          VERSION="$(mvn -q -DforceStdout help:evaluate -Dexpression=project.version)"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Find latest release tag
        id: prev
        shell: bash
        run: |
          set -euo pipefail
          git fetch --tags --force
          PREV_TAG="$(git tag -l 'v*' --sort=-v:refname | head -n 1 || true)"
          echo "prev_tag=$PREV_TAG" >> "$GITHUB_OUTPUT"

      - name: Decide whether this is a release
        id: decide
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${{ steps.ver.outputs.version }}"
          PREV="${{ steps.prev.outputs.prev_tag }}"
          TAG="v$VERSION"

          if [[ "$VERSION" == *"-SNAPSHOT" ]]; then
            echo "release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ -n "$PREV" && "$TAG" == "$PREV" ]]; then
            echo "release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "release=true" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Build + test
        if: steps.decide.outputs.release == 'true'
        run: mvn -B -U clean verify

      # ---- Publish step ----
      # Option A: GitHub Packages (works well if you want packages in GitHub).
      # Requires distributionManagement in pom.xml and auth using GITHUB_TOKEN.
      - name: Publish to GitHub Packages
        if: steps.decide.outputs.release == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: mvn -B deploy -DskipTests

      # Option B: If you publish elsewhere (Artifactory/OSSRH/etc), replace the step above
      # with mvn deploy -s settings.xml and required secrets.

      - name: Create and push tag
        if: steps.decide.outputs.release == 'true'
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.decide.outputs.tag }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG" -m "$TAG"
          git push origin "$TAG"

      - name: Generate release notes (since previous tag) + create GitHub Release
        if: steps.decide.outputs.release == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.decide.outputs.tag }}"
          PREV="${{ steps.prev.outputs.prev_tag }}"

          # Ask GitHub to generate the release name/body.
          # This API generates notes including "changes since last release". :contentReference[oaicite:3]{index=3}
          if [[ -n "$PREV" ]]; then
            NOTES_JSON="$(gh api "repos/$GITHUB_REPOSITORY/releases/generate-notes" \
              -f tag_name="$TAG" \
              -f target_commitish="$GITHUB_SHA" \
              -f previous_tag_name="$PREV")"
          else
            NOTES_JSON="$(gh api "repos/$GITHUB_REPOSITORY/releases/generate-notes" \
              -f tag_name="$TAG" \
              -f target_commitish="$GITHUB_SHA")"
          fi

          NAME="$(echo "$NOTES_JSON" | jq -r .name)"
          BODY="$(echo "$NOTES_JSON" | jq -r .body)"

          # Create the release using the generated notes.
          gh release create "$TAG" --title "$NAME" --notes "$BODY"
