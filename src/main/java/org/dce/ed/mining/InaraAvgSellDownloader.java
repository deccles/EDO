package org.dce.ed.mining;

import java.io.BufferedWriter;
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.Normalizer;
import java.time.Duration;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.Locale;
import java.util.Map;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Downloads INARA commodities list and extracts Avg sell price for each commodity.
 *
 * Source page (single request):
 *   https://inara.cz/elite/commodities-list/
 *
 * Expected columns:
 *   Commodity | Avg sell | Avg buy | Avg profit | Max sell | Min buy | Max profit
 */
public final class InaraAvgSellDownloader {

    private static final URI INARA_COMMODITIES_LIST = URI.create("https://inara.cz/elite/commodities-list/");

    /**
     * This regex is intentionally permissive:
     * - Finds a commodity link in a row (<a ...>NAME</a>)
     * - Then finds the first "Cr" value following it (Avg sell)
     *
     * It avoids relying on exact table/td class names, because INARA markup can shift.
     */
    private static final Pattern ROW_PATTERN = Pattern.compile(
            // Anchor with commodity name
            "<a\\s+[^>]*href\\s*=\\s*\"/elite/commodity/\\d+/\"[^>]*>([^<]+)</a>"
            // Then any tags/text until first credits value (Avg sell)
            + "(?:(?!</tr>).)*?"
            + "([0-9][0-9,]*)\\s*Cr",
            Pattern.CASE_INSENSITIVE | Pattern.DOTALL
    );

    private InaraAvgSellDownloader() {
    }

    /**
     * Download and parse INARA avg sell prices (Cr/t).
     *
     * @return map of commodity name -> avg sell Cr/t
     */
    public static Map<String, Integer> downloadAvgSellPrices() throws IOException, InterruptedException {
        HttpClient client = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(20))
                .followRedirects(HttpClient.Redirect.NORMAL)
                .build();

        HttpRequest req = HttpRequest.newBuilder()
                .uri(INARA_COMMODITIES_LIST)
                .timeout(Duration.ofSeconds(30))
                .header("User-Agent", "EDO/1.0 (Elite Dangerous Overlay; contact: you)") // be polite/identifiable
                .GET()
                .build();

        HttpResponse<String> resp = client.send(req, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));
        if (resp.statusCode() < 200 || resp.statusCode() >= 300) {
            throw new IOException("INARA request failed: HTTP " + resp.statusCode());
        }

        String html = resp.body();
        Map<String, Integer> out = new LinkedHashMap<>();

        Matcher m = ROW_PATTERN.matcher(html);
        while (m.find()) {
            String name = htmlDecode(m.group(1)).trim();
            String avgSellStr = m.group(2);

            if (name.isBlank() || avgSellStr == null) {
                continue;
            }

            int avgSell = parseIntWithCommas(avgSellStr);
            if (avgSell <= 0) {
                continue;
            }

            // Deduplicate by normalized key: INARA sometimes repeats headers/sections.
            // Prefer first occurrence; they should all be the same anyway.
            String key = normalizeKey(name);
            out.putIfAbsent(key, avgSell);
        }

        // Convert normalized keys back to a nicer canonical display name:
        // We donâ€™t actually have the original for duplicates if we normalize, so keep keys as names.
        // If you prefer to preserve original casing, store a second map and choose the "best" display.
        return out;
    }

    /**
     * Writes properties file (Key=AvgSell) sorted by key.
     */
    public static void writePropertiesFile(Path outputFile, Map<String, Integer> avgSellByName) throws IOException {
        // Sort keys for stable diffs
        Map<String, Integer> sorted = new TreeMap<>(Comparator.naturalOrder());
        sorted.putAll(avgSellByName);

        Files.createDirectories(outputFile.getParent());

        try (BufferedWriter w = Files.newBufferedWriter(outputFile, StandardCharsets.UTF_8)) {
            w.write("# Avg sell prices (Cr/t) from INARA commodities list\n");
            w.write("# Source: " + INARA_COMMODITIES_LIST + "\n");
            w.write("# Generated by InaraAvgSellDownloader\n");
            w.newLine();

            for (Map.Entry<String, Integer> e : sorted.entrySet()) {
                w.write(e.getKey());
                w.write("=");
                w.write(Integer.toString(e.getValue()));
                w.newLine();
            }
        }
    }

    /**
     * Convenience: download and write in one shot.
     */
    public static void downloadAndWrite(Path outputFile) throws IOException, InterruptedException {
        Map<String, Integer> prices = downloadAvgSellPrices();
        writePropertiesFile(outputFile, prices);
    }

    private static int parseIntWithCommas(String s) {
        String t = s.replace(",", "").trim();
        try {
            return Integer.parseInt(t);
        } catch (Exception e) {
            return -1;
        }
    }

    /**
     * Keep keys consistent with your existing normalizer approach (alphanumerics only),
     * but preserve readability by converting underscores/spaces is optional.
     *
     * Here we keep original words/spaces and just trim / normalize unicode.
     */
    private static String normalizeKey(String displayName) {
        String t = Normalizer.normalize(displayName, Normalizer.Form.NFKC).trim();
        // INARA sometimes uses non-breaking spaces or weird punctuation
        t = t.replace('\u00A0', ' ');
        // Collapse multiple spaces
        t = t.replaceAll("\\s+", " ");
        return t;
    }

    /**
     * Minimal HTML decode for common entities INARA uses.
     */
    private static String htmlDecode(String s) {
        String t = s;
        t = t.replace("&amp;", "&");
        t = t.replace("&quot;", "\"");
        t = t.replace("&#39;", "'");
        t = t.replace("&lt;", "<");
        t = t.replace("&gt;", ">");
        return t;
    }
    
    public static void main(String args[]) throws IOException, InterruptedException {
    	InaraAvgSellDownloader.downloadAndWrite(
    		    Path.of("src/main/resources/market/inara_avg_sell.properties")
    		);
    }
    public static String fetchHtmlWithBackoff(HttpClient client, URI uri) throws IOException, InterruptedException {
        HttpRequest req = HttpRequest.newBuilder()
                .uri(uri)
                .timeout(Duration.ofSeconds(30))
                .header("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 "
                        + "(KHTML, like Gecko) Chrome/120.0 Safari/537.36")
                .header("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
                .header("Accept-Language", "en-US,en;q=0.9")
                .GET()
                .build();

        // 5 attempts: ~1s,2s,4s,8s,16s (max ~31s sleep)
        long sleepMs = 1000;
        for (int attempt = 1; attempt <= 5; attempt++) {
            HttpResponse<byte[]> resp = client.send(req, HttpResponse.BodyHandlers.ofByteArray());
            int code = resp.statusCode();

            if (code >= 200 && code < 300) {
                return new String(resp.body(), StandardCharsets.UTF_8);
            }

            // transient-ish: 503/502/504/520/521/522/524
            if (code == 503 || code == 502 || code == 504 || (code >= 520 && code <= 524)) {
                if (attempt == 5) {
                    throw new IOException("INARA request failed: HTTP " + code + " after retries");
                }
                Thread.sleep(sleepMs);
                sleepMs *= 2;
                continue;
            }

            throw new IOException("INARA request failed: HTTP " + code);
        }

        throw new IOException("INARA request failed: retry loop ended unexpectedly");
    }
}
